#include <iostream>
#include <string>
#include <unordered_map>
-----------------
struct Task {
    std::string description;
    std::string date;
    int priority; // Lower values indicate higher priority
    // You can include other attributes like due date, etc.

    Task(const std::string& desc, const std::string& d, int prio)
        : description(desc), date(d), priority(prio) {}
};
--------------------
struct Node {
    Task task;
    Node* prev;
    Node* next;

    Node(const Task& t) : task(t), prev(nullptr), next(nullptr) {}
};
--------------------
class TaskManager {
private:
    Node* head;
    std::unordered_map<std::string, Node*> calendar;

public:
    TaskManager() : head(nullptr) {}

    // Function to add a task at the end of the list

    void addTask(const Task& task) {
        Node* newNode = new Node(task);

        if (!head) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next) {
                current = current->next;
            }
            current->next = newNode;
            newNode->prev = current;
        }
.........................................................................

        // Add the task to the calendar

        calendar[task.date].emplace_back(newNode);

        // Set priorities only if there are more than 2 tasks on the same day
        if (calendar[task.date].size() > 2) {
            prioritizeTasks(calendar[task.date]);
        }
    }
....................................................................................
    // Function to delete a task at a specific position
    void deleteTask(int position) {
        Node* current = head;
        int currentPosition = 1;

        while (current && currentPosition < position) {
            current = current->next;
            currentPosition++;
        }

        if (current) {
            if (current->prev) {
                current->prev->next = current->next;
            } else {
                head = current->next;
            }

            if (current->next) {
                current->next->prev = current->prev;
            }

            // Remove the task from the calendar
            calendar[current->task.date].remove(current);

            delete current;
            std::cout << "Task at position " << position << " deleted successfully!\n";
        } else {
            std::cout << "Invalid position. No task deleted.\n";
        }
    }
........................................................................................................
    // Function to prioritize tasks based on user input

    void prioritizeTasks(const std::list<Node*>& tasks) {
        std::cout << "Setting priorities for tasks on the same day.\n";
        for (Node* node : tasks) {
            std::cout << "Enter priority for task '" << node->task.description << "': ";
            std::cin >> node->task.priority;
        }

        // Sort the list based on priority
        tasks.sort([](const Node* a, const Node* b) { return a->task.priority < b->task.priority; });
    }
.................................................................................................................
    // Function to display the entire task sequence

    void displayTasks() const {
        Node* current = head;

        std::cout << "Task List:\n";
        while (current) {
            std::cout << "Description: " << current->task.description << "\n";
            std::cout << "Date: " << current->task.date << "\n";
            std::cout << "Priority: " << current->task.priority << "\n\n";
            current = current->next;
        }
    }
.............................................................................................................................
    // Function to display the entire calendar schedule

    void displayCalendar() const {
        std::cout << "Calendar Schedule:\n";
        for (const auto& entry : calendar) {
            for (Node* node : entry.second) {
                std::cout << "Date: " << entry.first << "\n";
                std::cout << "Description: " << node->task.description << "\n";
                std::cout << "Priority: " << node->task.priority << "\n\n";
            }
        }
    }
};
...........................................................................................
int main() {
    TaskManager taskManager;
    int choice;

    do {
        std::cout << "\nTask Management Interface:\n";
        std::cout << "1. Add Task\n";
        std::cout << "2. Delete Task\n";
        std::cout << "3. Display Tasks\n";
        std::cout << "4. Display Calendar\n";
        std::cout << "5. Exit\n";
        std::cout << "Enter your choice: ";
        std::cin >> choice;

        switch (choice) {
            case 1: {
                std::string description, date;
                int priority;

                std::cin.ignore(); // Clear the newline character from the buffer

                std::cout << "Enter task description: ";
                std::getline(std::cin, description);

                std::cout << "Enter task date: ";
                std::getline(std::cin, date);

                // Assume priority is 0 initially, user can set it later if applicable
                taskManager.addTask(Task(description, date, 0));
                break;
            }

            case 2: {
                int position;
                std::cout << "Enter the position of the task to delete: ";
                std::cin >> position;
                taskManager.deleteTask(position);
                break;
            }
            case 3:
                taskManager.displayTasks();
                break;
            case 4:
                taskManager.displayCalendar();
                break;
            case 5:
                std::cout << "Exiting the Task Management Interface. Goodbye!\n";
                break;
            default:
                std::cout << "Invalid choice. Please enter a valid option.\n";
        }

    } while (choice != 5);

    return 0;
}
